\section{Software to use}
\begin{itemize}
    \item Ros, unity and python.
\end{itemize}

\section{The specific data format / The data given}
As written in \ref{dataset} the data is of the IFC format. Actually the data is generated by Dalux from the IFC format. Dalux takes the IFC data of a building and passes it through their parser that generates 5 xml files: rooms.xml, floorplaninfo.xml, levels.xml, structure.xml and properties.xml and generate one .txt file named: output.txt. Therefore this project does not actually work with any IFC file.
The rooms.xml file has information about the rooms in the floor plan. Basically the floor plan is generated as a collection of rooms. The coordinates of the rooms are triangles spanning the room. Each room has associated with it its minimum elevation level and its maximum elevation level which represent the height of the floor and the height of the ceiling of the room. These elevation levels are the ones used to choose which rooms to include in the floorplan.

The floorplaninfo.xml file has information about the doors of the rooms. For each door the file has information about its origin point i.e the coordinate placement of the door. Furthermore it has information about the height of the door. It also has information about the direction that the door is facing, given as a unit vector.

In the output.txt file information about the translation is given. In some buildings this is needed to translate the door coordinates so that they align with the floorplan. [insert picture of them not aligning]

The rest of the files are not used in this project since they consist mostly of semantic information of the building.

In normal circumstances an IFC loader could be used to load IFC files. Since in this case the files are not IFC files but are Dalux' own data format derived from IFC files, a separate loader had to be constructed. 




\subsection{Loading the data}
The overall program consists of 3 scripts: read\_write.py, coordinate\_processing.py and plotting\_data.py.
The script read\_write.py is used to load the data. It takes the floor plan data as input and uses the xml.etree.ElementTree module to append the coordinates of each room to a list and the coordinates of the doors to another list. Both lists are parsed to a csv file.

%\subsection{Preprocessing of the data set}
Before working with the data set some preprocessing had to be done. This included splitting the array values in appropriate ways and gathering them in sets of three such as to align with the triangles they would form. The coordinate\_processing.py module was made to handle this.


\section{Plotting floor plan}
It is always a good idea to get an overview of the data used in a project. This is especially the case in this project since the data in this case is a visual representation of something physical - a floor plan of a building. It therefore made sense to find a good way to transform the data from its original form to a plot that visualises how the floor plan looks. This will be useful throughout the project because it will act as a clear visual indicator of potential errors occurring in the program; we will quickly see if a path goes through a wall or if door nodes are not placed where they should be placed. This would not be the case if we omitted to plot the floor plan and only plotted the graph and the route.
\\\\
A random floor is chosen among the different floors of the building. This is done by checking the MinimumElevation value given in the rooms.xml file. For each room if it has a specific minimum elevation value the program keeps the room. 
%\subsection{Plotting the doors}
\\\\
When plotting the doors a challenge occurred, which was that a transformation had to be performed on the doors before they were aligned with the rest of the floor plan. This would only sometimes be the case. The information about the translation could be found in the output.txt file.
\\\\
For the doors a csv file is constructed which consists of the coordinate of each door and the direction it is facing. The last line of the csv file includes the coordinate translation.
\\\\
For each door point a complementary door point will be added. This complementary door point will be  added on the other side of the wall that the original door point is facing, using the direction information of the doors. This makes it possible to go through walls when solving for the path, since complementary doors always will be connected.
\\\\
The correct doors are chosen for the right floor plan using the height information related to the doors. These do not always match in scale and a translation will on some buildings have to be performed. The program checks if this is needed.

\begin{itemize}
    \item Talk about difference between using minimum elevation or clippingHeight.
\end{itemize}


\subsection{Removing redundant lines}
The triangle structure of the data set forms a mesh that spans the entire floor plan. If just plotted as is this does not do a great job of visualising the floor plan in an appropriate way, since a lot of unwanted lines will be there. [insert figure of the floor plan with triangles]. Some processing has to be done to remove these unwanted lines and make the rooms in the floor plan distinguishable from each other. The idea of how to go about this problem came from \cite{wayfinding} where they also met the same challenge. The intuition behind their idea was that the lines to be removed are part of more than one triangle, if e.g two triangles are used to span a room the line that should be removed is the one shared by both triangles. In order for this to work each line had to be hashed. There are some slight modifications to the way hashing is performed in this project compared to their project. In this project each line is hashed, where they hash each point in their project.

[insert flowchart of the process of hashing, and also a sketch describing it]

\begin{itemize}
    \item Explain that we wish to remove lines of the shared triangle. Insert a sketch that explains what we want to do.
\end{itemize}

%For each triangle the program hash all lines in that triangle in a dictionary in both direction. This means that we hash 6 lines per triangle. The reason for this is that a triangle might have the same line as another triangle but in reverse order. These two lines should be seen as the same. Therefore we have to hash both directions of each line in every triangle.

%For example say we have a line in one triangle (x1,y1) - (x2,y2). What might be the case is that another other triangle might have the same lines as the first triangle but as (x2,y2) - (x1,y1). Therefore the program hashes the line (x2,y2)-(x1,y1) as well. Just like the other triangle both directions will be hashed meaning (x1,y1)-(x2,y2). The way hashing works is that two identical values will give the same hash key. In this example we now have two values for two different hash keys, since the same line is occuring twice in two different hashes.

%Now each dictionary element that has more than one value is removed. Therefore both of the hashes will be removed and we have made sure that the line is correctly removed.
%The way we hash also has the consequence of having each line existing twice in the dictionary. Therefore one of the directions of each line is removed. This makes the dictionary half as long and makes it more efficient for use later if need be.

%%The idea here is to make a dictionary where each line a set of two point coordinates is given a key and the same lines will have the same key. For example the point set of The way to make sure that the same lines will get the same key is by using hashing. Then all keys with more than one value (line) will be removed. The idea of using hashing to remove redundant lines was taken from this project (insert project reference).

\section{Spatial data structure framework}
As already explained the spatial data structure is a useful tool to store spatial elements in a data structure. In this program the following elements are stored in a spatial data structure:
\begin{itemize}
    \item The rooms
    \item The walls
    \item The nodes
\end{itemize}
The spatial data structure for the rooms will allow the program to access quickly which rooms each node belongs to, the usefulness of which will be discussed further here \ref{room_labels}.
The structure for the walls is used to create a buffer zone between the walls and the rest of the building. It will be used to investigate which nodes in the grid graph will have to be removed due to being too close to a wall.
The least necessary out of the three data structures is arguably the one made for the nodes. This is used to such that the doors are connected to the closest node inside the same room as itself. 

The reason these spatial data structure are suitable to use in this project is because they allow for faster nearest neighbour search. For each of the examples explained above the use of these datastructures has made accessing the nearest room, wall or node faster and therefore the overall program faster.
An alternative brute force solution that could be used is to iterate through every room, wall and node to find the nearest object. The datastructure is therefore not strictly necessary but highly advantageous to the alternative brute force solution. 
%From a more intuitive perspective the idea of using spatial datastructures to solve a spatial problem also makes sense.  
%Since this project works on solving a geometric problem that occurs in space it is appropriate to work with spatial datastructures. 

There exist different kinds of spatial datastructures though many of them work only with point objects. Due to the fact that 2 out of 3 of the objects that the program wish to store are multidimensional, the R-tree data structure - which work with multidimensional objects - was chosen.

% The below might be better of in an implementation section
%To make the Rtree data structure was simply a matter of either implementing my own Rtree data structure class or using an existing framework, the latter option was chosen.

The framework used to make the Rtree data structure, was the Rtree module from python \cite{rtree_module}. 
%Visit this documentation for more information on how this module works.

Although the Rtree module is designed to store multidimensional objects like rooms and wall, this data structure was also chosen to store the node objects which are not multidimensional.
This might not be the optimal way to store point objects but to simplify the program and minimize the number of different frameworks used in the program the Rtree was also chosen for this datatype. Using another spatial data structure for the point objects is a very reasonable alternative.


\section{Sampling the graph}
%Making a graph to represent the path and the places that Spot should visit was from the start the very straightforward way to go about the problem. 
The standard framework used when working with graphs in python is the Networkx library. This was also the framework chosen in this program to work with graphs.
As explained in \ref{design} Making a grid graph was chosen to represent the building with a resolution of 0.5x0.5 for x and y direction. The reason behind this resolution was that it would allow the entirety of Spot to fit within each node of the graph. This way each node could either be deemed traversable or not traversable by Spot.

Each node created in the graph would have the following attributes associated with it: the point coordinate, the distance to the closest wall, the node type i.e is it a door node or grid node. Later when doing the room labeling, the room number would also be an attribute to the node. 
The distance to the closest wall could be found by making use of the R-tree generated for the walls. The motivation behind including this attribute was to be able to remove the nodes that were within a certain distance to the closest wall. Including the coordinate of the node was also necessary in many different sections of the program. The same with the node type labeling. Furthermore an R-tree data structure for the nodes would also be implemented while generating the grid nodes.

Since the graph would be as a grid each node would have an edge to eight other nodes in the grid. Knowing the length of the columns of the grid it was possible to connect each node to a the node diagonal, vertical and horizontal to it. 

\begin{itemize}
    \item Explain how exactly you managed to connect the nodes
\end{itemize}

When all the nodes would be generated the nodes within a certain distance of the walls would be removed along with their edges.

\subsection{The door nodes}
Originally the doors were also discretized to fit into the grid, which would move the doors to the closest grid point. This showed itself to be problematic because the doors would move to another position than they were actually placed. 
There were a few problems with this. One was that it could cause problems when Spot would want to walk through the door and the door would actually be a maximum of 25 cm away from its actual position. This was somewhat concerning but might still have been a durable solution since Spot has the ability to detect obstacles and move around them and therefore might have been able to move through the door anyway.
The bigger issue with discretizing the doors was that the doors would sometimes move just enough that they no longer were connected to the same room. Although this was a rare occurrence it could pose a big problem in the robustness of the program.

With these two things in mind it was decided to not discretize the doors, and thereby keep undiscretized doors in a discretized grid, at the cost of complicating the program a bit.

The doors would have edges to only two nodes in the graph, one would be its complementary door node and the other node would be the closest node with the same room label as the door node. 
%Which leads to the next section.

%After I remove nodes near the walls, (and before I remove door nodes that are outside the building) I check for each door whether or not it is connected to more than one other node. If it is only connected to the 1 other node it means that it is only connected to its complementary door. In this case the door should connect itself to a random node in the room. In this case the program should connect the door to the nearest node that is not crossing a wall. I need a spatial data structure for the nodes.


\section{Room labels}\label{room_labels}
In order to generate the room nodes of the room graph it is necessary to first label each grid node to the room it is inside of. [Insert flowchart that illustrates the algorithm and heuristic]

The program iterates through each node in the grid and finds the nearest rooms to that node using the R-tree generated for the rooms. Sometimes due to the way the data is formatted a node can be inside multiple rooms at the same time. Therefore the program finds the area of the rooms and sort them such that the node is tested to be within the smallest room first. This is because the rooms are sometimes inside each other.
When checking if the node is inside the room the ray casting algorithm is used together with line intersection. In theory it should be enough to check one direction to decide whether the node is within the room or not. This is not the case here however, mainly due to the fact that other elements are included in the floor plan. One example are pillars that can be present in the floor plan and could therefore interfere with the line intersection. 
Therefore 4 directions are checked and a majority voting system is used to decide whether the node is inside or outside the room.
If a node is not inside any rooms it is removed from the graph since this means that it is outside the building and therefore shouldn't be a part of the path under any circumstances.

Labeling the rooms serve a few functions. One of the places that it is used is when generating the room nodes using the K-means algorithm. Without knowing how many rooms there are or knowing which nodes belong to which rooms, we can not make sure that each room has a minimum of one room node associated with it.
One of the other functions of the room labeling is that it removes nodes that are outside the building. This is because outside nodes will not be part of any rooms, and are as a result removed. Doing this insures that Spot does not traverse outside the building. [Show example where it traverses outside the building]


There are some special cases where this algorithm will not remove outside nodes. This could for example be the case if the building consisted of a yard inside of it. [insert a sketch] Depending on how the architect labeled the rooms this could be an issue. The counter argument would then be that it might not be a problem for Spot to be walking in the yard in that case since the yard is part of the building. It might also allow for a faster traversal through the building. 

\section{Node placement}
As explained in \ref{room_graph} Different options exist for generating the room nodes that made up the room graph. One option and the option that was used in the end was to use a clustering algorithm to generate the nodes, more specifically the K-means algorithm. 
The K means algorithm was implemented and the number of centroids were chosen by a ratio of the number of nodes in the room. This way bigger rooms would have more centroids i.e. room nodes. In the case that the centroid falls outside the room a new centroid is chosen randomly from the nodes in the room. The K-means stops after five iteration, and after one iteration if there is only one room node in the room. 

%One could choose a more sophisticated convergence criteria, but this was not deemed necessary since finding the perfect spot for the centroids were not important.
\begin{itemize}
    \item Exlain other convergence criteria.
\end{itemize}
%\section{Making sure that doors are connected to nodes in room}

%\section{How to choose the correct doors and floorplan}

%\section{Choosing the floorplan}
%- rooms are in other rooms.

%\section{Bugs and challenges}
%- Make a list of all the challenges and bugs and write a section for each of them.


\subsection{Connecting the room graph}
%To make a graph placing the nodes are not the only thing needed to be done, adding the edges is also necessary. 
To solve the TSP approximate solution for this graph a prerequisite is to make the room graph complete. Therefore edges between all nodes in this graph were to be added.
However before doing this, as a robustness check the program checks if all of the room nodes are connected. This is done using the Networkx library which has a function that can check how many nodes need to be removed before there is no longer connection between two nodes, if this number is zero it means that the two nodes are not connected. The room nodes that are not connected to the rest of the graph are removed.
After making sure that the nodes are indeed connected it is time to create edges between the nodes. The weight of the edges were found by finding the shortest path between each of the nodes. This was found using the A star algorithm. 

%\begin{itemize}
%    \item Are there different ways to do this?
%\end{itemize}

\section{Tsp solution}

\begin{itemize}
    \item How was this exactly implemented
\end{itemize}




\section{What the data lacks}
A big challenge to the program occurred when there were walls in the floor plan that seemed misplaced. Investigating the 3D model of the building it seemed that these walls were not supposed to be there. The distinction between what is illustrated in the 3D model and what is shown when the program plots is caused due to the fact that not all information from the BIM model is parsed to the six files generated by Dalux. 

There is no information in the data that indicates which lines represent walls and which lines do not represent walls. As a general case every line on the floor plan represent walls but this is not always the case. It depends on how the architect decided to design the building. Take for example the following building [insert figure], here these rooms are in reality one big open space, but the designer deemed it useful to separate this open space into three rooms and therefore there are lines separating the rooms. 

The issue as can be seen in the figure below [insert figure] is that since these lines will not have doors connected with it they will result in blocking of the path. Spot might therefore not be able to traverse to all the rooms in the floor plan.

A big portion of energy was used to reconcile this distinction between what is plotted and what is actually the case and find ways to tackle this issue. Since there is no information given in the files about which lines represent walls, a heuristic had to be found solve the issue.



\subsection{One wall algorithm, walls that are not supposed to be there}
From investigating the difference between the lines that were supposed to represent walls and the lines that were not supposed to represent walls a realisation came. It seemed that the walls separating the rooms often consisted of two parallel lines with a small separation between the lines. This seemed to indicate the thickness of the wall. The reason for these double lines comes from the fact that when the rooms are generated they do not share lines. On the other hand it seemed that when there was not supposed to be this line separation the two rooms shared the same wall. Another way to view this was that the line represented a wall with thickness 0.

With that in mind a heuristic was implemented that would check all rooms if lines were overlapping or shared. 
This was done by comparing line for line in two for loops. 
There are two scenarios where the wall can be removed. 
The first scenario is if the two line segments are identical.
The second scenario is if the line segments are overlapping i.e. one line segment is a part of another line segment.
[insert figure of different scenarios]

This is done by checking the slopes of the points making up the line segments, if the slope of all the points of the two line segments are the same it means that they are co-linear. This does not necessary mean that they are overlapping. To figure this out a projection on the x axis is performed. In the special case of vertical lines a projection on the y-axis is performed. If  one of the points of one line segment is overlapping with the other line segment this means that the line segments overlap [insert figure]. 
Before removing the line segment we check if there are doors within a certain distance of the wall. This is because we do not want to remove lines that have doors connected to it since this means that the line is actually a wall or that the doors are supposed to be used to traverse the line.

The results of using this heuristic were not perfect as can be seen from the results section \ref{results}, they were however an improvement to not using it.


%In this project a loader was made to load the data and plot it. It is worth saying that there are alternative pre-made loaders to do this. For example [IFC open shell loader, insert reference]. I chose to make my own loader because at the time it seemed like the straight forward thing to do. I was assured that the data was made in a certain way by Dalux, and since the data was given in a specific format and consisted of a small part of what a true IFC file consists of I decided to make my own loader. If the user wants to use this program for general IFC files it is simply a matter of using a already existing IFC loader, like the one mentioned earlier.